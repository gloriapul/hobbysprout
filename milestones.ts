/**
 * Milestones Concept - AI Augmented Version
 */

import { GeminiLLM } from './gemini-llm';

/**
 * Represents a single step in the milestone
 * @property description - The description of the step (max 200 characters)
 * @property startDate - When the step was created
 * @property completionDate - When the step was completed (if completed)
 * @property isComplete - Whether the step is completed
 */
export interface MilestoneStep {
    description: string;
    startDate: Date;
    completionDate?: Date;
    isComplete: boolean;
}

export interface Milestone {
    goal: string;
    steps: MilestoneStep[];
    isActive: boolean; // would become important in later version since looking at users working on one hobby at a time
}

export class Milestones {
    private goal: string = '';
    private steps: MilestoneStep[] = [];
    private isActive: boolean = true;

    /**
     * Validates goal or step input
     * @param item The item to validate
     * @throws Error if item is invalid
     */
    private validateItem(item: string): void {
        if (!item || item.trim().length === 0) {
            throw new Error('Cannot be empty');
        }
        if (item.trim().length > 200) {
            throw new Error('Description is too long (max 200 characters)');
        }

        if (this.steps.some(step => step.description === item) || this.goal === item) {
            throw new Error('Already exists');
        }
    }

    /**
     * Validates the quality and structure of steps generated by the LLM
     * @param steps Array of step descriptions to validate
     * @throws Error if any step:
     *  - Contains vague/uncertain language (e.g., "etc", "maybe", "if needed")
     *  - Is too verbose (more than 3 commas indicating multiple actions)
     *  - Is too long (> 200 characters) or too brief (< 20 characters)
     */
    private validateStepLogic(steps: string[]): void {
    // 1. check for overly vague steps
    const vagueWords = ['etc', 'maybe', 'possibly', 'and more', 'as necessary'];
    steps.forEach(step => {
        if (vagueWords.some(word => step.toLowerCase().includes(word))) {
            throw new Error(`Vague step detected: "${step}". Steps must be specific and actionable`);
        }
    });

    // 2. check step level of details and potential run-on statements
    steps.forEach(step => {
        if ((step.match(/,/g) || []).length > 6) {
            throw new Error(`Step too verbose: "${step}". Break into simpler steps, for example: "Use basic photo editing tools to enhance the image"`);
        }
    });

    // 3. check step length
    steps.forEach(step => {
        if (step.length > 300) {
            throw new Error(`Step too detailed: "${step}". Keep each step brief and focused on one main action`);
        }
        if (step.length < 20) {
            throw new Error(`Step too brief: "${step}". Provide more detail to clarify the action`);
        }
    });
    }

    /**
     * Sets the goal for this milestone
     * @param goal The goal to set (max 200 characters)
     * @throws Error if goal is empty
     * @throws Error if goal is too long (more than 200 characters)
     * @throws Error if goal already exists
     * @returns The set goal
     */
    setGoal(goal: string): string {
        this.validateItem(goal);

        this.goal = goal;
        return goal;
    }

    /**
     * Generates steps for the goal using the Gemini LLM
     * @param llm The Gemini LLM instance to use for the step generating
     * @throws Error if goal is not set
     * @throws Error if LLM response is invalid
     * @throws Error if no valid steps were generated
     * @returns Array of generated milestone steps
     */
    async generateSteps(llm: GeminiLLM): Promise<MilestoneStep[]> {
        if (!this.goal) {
            throw new Error('Goal must exist');
        }

        const prompt = `
        You are a helpful AI assistant that creates a recommended plan of clear steps for people looking to work on a hobby.

        Create a structured step-by-step plan for this goal: "${this.goal}"

        Response Requirements:
        1. Return ONLY a single-line JSON array of strings
        2. Each string should be a specific, complete, measurable, and actionable step
        3. Step must be relevant to the goal and feasible for an average person, should not be overly ambitious or vague
        4. Only contain necessary steps to achieve the goal, avoid filler steps and be mindful of number of steps generated
        5. Steps must be in logical order
        6. Do NOT use line breaks or extra whitespace
        7. Properly escape any quotes in the text
        8. No step numbers or prefixes
        9. No comments or explanations

        Example response format:
        ["Research camera settings and features","Practice taking photos in different lighting","Review and organize test shots"]

        Return ONLY the JSON array, nothing else.`;

        let response = await llm.executeLLM(prompt);

        // parsing llm response
        response = response.trim();
        try {
            // first clean up basic formatting
            response = response.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();

            // get array portion
            const arrayMatch = response.match(/\[(.*)\]/);
            if (!arrayMatch) {
                console.error('Response format:', response);
                throw new Error('Response is not in the expected array format');
            }

            // clean up array content as a caution
            const arrayContent = arrayMatch[1]
                .replace(/,\s*]/g, ']') // trailing commas
                .replace(/,\s*,/g, ',') // double commas
                .replace(/\\"/g, '"') // escaped quotes
                .trim();

            let steps: string[];
            try {
                // try parsing as JSON first
                steps = JSON.parse(`[${arrayContent}]`) as string[];
            } catch (parseError) {
                // if JSON parse fails, try manual splitting
                steps = arrayContent.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
                    .map(step => step.trim().replace(/^["']|["']$/g, ''))
                    .filter(step => step.length > 0);
                
                if (steps.length === 0) {
                    throw new Error('Could not extract valid steps from response');
                }
            }

            this.validateStepLogic(steps);

            if (!Array.isArray(steps) || steps.length === 0) {
                throw new Error('Response did not contain valid steps');
            }
        
            this.steps = steps.map(description => ({
                description,
                isComplete: false,
                startDate: new Date()
            }));

            return this.steps;
        } catch (error) {
            console.error('❌ Error generating steps:', error);
            throw error;
        }
    }

    /**
     * Adds a step inputted by user
     * @param description The step description (max 200 characters)
     * @throws Error if goal is not set
     * @throws Error if description is empty
     * @throws Error if description is too long (> 200 characters)
     * @returns Updated array of all milestone steps
     */
    setSteps(description: string): MilestoneStep[] {
        if (!this.goal) {
            throw new Error('Goal must exist');
        }
        this.validateItem(description);

        const step: MilestoneStep = {
            description,
            isComplete: false,
            startDate: new Date()
        };

        this.steps.push(step);
        return this.steps;
    }

    /**
     * Marks a step as complete
     * @param description The step to complete
     * @throws Error if step not found or not in progress
     */
    completeStep(description: string): MilestoneStep[] {
        const step = this.steps.find(s => s.description === description);
        if (!step) {
            throw new Error('Step not found');
        }
        if (step.isComplete) {
            throw new Error('Step is already complete');
        }

        step.isComplete = true;
        step.completionDate = new Date();

        if (this.steps.every(s => s.isComplete)) {
            this.closeMilestones(); // goal is complete
        }

        return this.steps;
    }

    /**
     * Closes the milestone, this indicates that the user has completed their goal or has decided to abandon their goal
     * @throws Error if milestone is not active
     */
    closeMilestones(): void {
        if (!this.isActive) {
            throw new Error('Milestone is already not active');
        }
        this.isActive = false;
    }

    /**
     * Gets all steps in the milestone
     * @returns Array of MilestoneStep objects containing description, completion status, and dates
     */
    getSteps(): MilestoneStep[] {
        return this.steps;
    }

    /**
     * Gets the current goal of the milestone
     * @returns The goal string, or empty string if no goal is set
     */
    getGoal(): string {
        return this.goal;
    }

    /**
     * Checks if the milestone is still active or has been completed/abandoned
     * @returns Boolean indicating if the milestone is still active
     */
    getIsActive(): boolean {
        return this.isActive;
    }
}